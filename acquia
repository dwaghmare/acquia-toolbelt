require "rubygems"
require "thor"
require "netrc"
require "highline/import"
require "faraday"
require "json"

class Acquia < Thor
  # A no_commands block is designed to show the methods that cannot be invoked
  # and as such, do not have a description.
  no_commands {
    # Internal: Used for outputting a pretty success message.
    #
    # Returns the coloured and formatted string.
    def success(text)
      puts "\e[#32m#{text}\e[0m"
    end

    # Internal: Used for outputting a pretty error message.
    #
    # Returns the coloured and formatted string.
    def fail(text)
      puts "\e[#31m#{text}\e[0m"
    end

    # Internal: Used for outputting a pretty info message.
    #
    # Returns the coloured and formatted string.
    def info(text)
      puts "\e[#36m#{text}\e[0m"
    end

    # Internal: Create a request to the Acquia API.
    #
    # The request generated contains all the correct user authentication and
    # headers.
    #
    # Returns a JSON string of the body.
    def acquia_api_call(resource, method = "GET", data = {})
      n = Netrc.read
      @acquia_user, @acquia_password = n["cloudapi.acquia.com"]

      conn = Faraday.new
      conn.basic_auth(@acquia_user, @acquia_password)

      case method
      when "GET"
        response = conn.get "https://cloudapi.acquia.com/v1/#{resource}.json"
        response.body
      when "POST"
      when "DELETE"
        response = conn.delete "https://cloudapi.acquia.com/v1/#{resource}.json"
        response.body
      else
      end
    end

    # Internal: Get defined subscription environments.
    #
    # This is a helper method that fetches all the available environments for a
    # subscription and returns them for use in other methods.
    #
    # Returns an array of environments.
    def get_acquia_environments(subscription)
      env_data = JSON.parse(acquia_api_call("sites/#{subscription}/envs"))

      envs = []
      env_data.each do |env|
        envs << env["name"]
      end

      envs
    end

    # Internal: Truncate a SSH key to a secure and recognisable size.
    #
    # Displaying whole SSH keys is probably a bad idea so instead we are getting
    # the first 30 characters and the last 100 characters of the key and
    # separating them with an ellipis. This allows you to recognise the
    # important parts of the key instead of the whole thing.
    #
    # Returns string.
    def truncate_ssh_key(ssh_key)
      front_part = ssh_key[0...30]
      back_part  = ssh_key[-50, 50]
      new_ssh_key = "#{front_part}...#{back_part}"
    end
  }

  # Public: Log into the Acquia Cloud API.
  #
  # This sets up the user account within the netrc file so that subsequent
  # calls can reuse the authentication without the user being prompted for it.
  #
  # Returns the status of your login attempt.
  desc "login", "Login to your Acquia account."
  def login
    user = ask "Enter your username:"
    password = ask "Enter your password:"

    # Update (or create if needed) the netrc file that will contain the user
    # authentication details.
    n = Netrc.read
    n.new_item_prefix = "# This entry was added for connecting to the Acquia Cloud API\n"
    n["cloudapi.acquia.com"] = user, password
    n.save

    success "Your user credentials have been successfully set."
  end

  # Public: Display an overview of the subscriptions.
  #
  # Returns all subscriptions with their respective data.
  desc "list-subscriptions", "Find all subscriptions that you have access to."
  def list_subscriptions
    subscriptions = JSON.parse(acquia_api_call("sites"))

    subscriptions.each do |subscription|
      say
      # Get the individual subscription information.
      subscription_info = JSON.parse(acquia_api_call("sites/#{subscription}"))
      say "#{subscription_info["title"]}"
      say "> Username: #{subscription_info["unix_username"]}"
      say "> Subscription: #{subscription_info["name"]}"

      # If the VCS type is SVN, we want it in all uppercase, otherwise just
      # capitilise it.
      if subscription_info["vcs_type"] == 'svn'
        say "> #{subscription_info["vcs_type"].upcase} URL: #{subscription_info["vcs_url"]}"
      else
        say "> #{subscription_info["vcs_type"].capitalize} URL: #{subscription_info["vcs_url"]}"
      end
    end
  end

  # Public: Provide an overview of the environments in your subscription.
  #
  # Returns the environment data in a pretty format.
  desc "list-environments <subscription>", "Provide an overview of the environments in your subscription."
  option :environment, :aliases => "-e"
  def list_environments(subscription)
    # If the environment option is set, just fetch a single environment.
    if options[:environment]
      subscriptions_details = JSON.parse(acquia_api_call("sites/#{subscription}/envs/#{options[:environment]}"))

      say "> Host: #{subscriptions_details["ssh_host"]}"
      say "> Environment: #{subscriptions_details["name"]}"
      say "> Current release: #{subscriptions_details["vcs_path"]}"
      say "> DB clusters: #{subscriptions_details["db_clusters"].to_s unless subscriptions_details["db_clusters"].nil?}"
      say "> Default domain: #{subscriptions_details["default_domain"]}"
      return
    end

    subscription_envs = JSON.parse(acquia_api_call("sites/#{subscription}/envs"))
    subscription_envs.each do |env|
      say
      say "> Host: #{env["ssh_host"]}"
      say "> Environment: #{env["name"]}"
      say "> Current release: #{env["vcs_path"]}"
      say "> DB clusters: #{env["db_clusters"].to_s unless env["db_clusters"].nil?}"
      say "> Default domain: #{env["default_domain"]}"
    end
  end

  # Public: Get server specs and information from an environment.
  #
  # This allows the ability to get all the server data from all server types
  # that are available within the subscription's environments.
  #
  # Returns server information on a per environment basis.
  desc "list-servers <subscription> <environment>", "Get a list of servers specifications for an environment."
  def list_servers(subscription, environment)
    server_env = JSON.parse(acquia_api_call("sites/#{subscription}/envs/#{environment}/servers"))

    server_env.each do |server|
      say
      say "> Host: #{server["fqdn"]}"
      say "> EC2 region: #{server["ec2_region"]}"
      say "> Availability zone: #{server["ec2_availability_zone"]}"
      say "> EC2 instance type: #{server["ami_type"]}"

      # Show how many PHP processes this node can have. Note, this is only
      # available on the web servers.
      if server["services"] && server["services"]["php_max_procs"]
        say "> PHP max processes: #{server["services"]["php_max_procs"]}"
      end

      if server["services"] && server["services"]["status"]
        say "> Status: #{server["services"]["status"]}"
      end

      if server["services"] && server["services"]["web"]
        say "> Web status: #{server["services"]["web"]["status"]}"
      end

      # The state of varnish.
      if server["services"] && server["services"]["varnish"]
        say "> Varnish status: #{server["services"]["varnish"]["status"]}"
      end

      # Only load balancers will have the "external IP" property.
      if server["services"] && server["services"]["external_ip"]
        say "> External IP: #{server["services"]["external_ip"]}"
      end
    end
  end

  # Public: Get all databases in the subscription.
  desc "databases", "Get information on the database servers within your subscription."
  def databases
    say "getting databases"
  end

  # Public: Get users on the subscription.
  desc "list-users <subscription>", "Find out who has access and keys within your subscription."
  def list_users(subscription)
    users = JSON.parse(acquia_api_call("sites/#{subscription}/sshkeys"))

    users.each do |user|
      say
      say "> Name: #{user["nickname"]} (#{user["id"]})"
      say "> Key: #{truncate_ssh_key user["ssh_pub_key"]}"
    end
  end
end

Acquia.start
